// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../node_modules/parcel-bundler/src/builtins/bundle-url.js":[function(require,module,exports) {
var bundleURL = null;

function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }

  return bundleURL;
}

function getBundleURL() {
  // Attempt to find the URL of the current script and use that as the base URL
  try {
    throw new Error();
  } catch (err) {
    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);

    if (matches) {
      return getBaseURL(matches[0]);
    }
  }

  return '/';
}

function getBaseURL(url) {
  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)\/[^/]+$/, '$1') + '/';
}

exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
},{}],"../node_modules/parcel-bundler/src/builtins/css-loader.js":[function(require,module,exports) {
var bundle = require('./bundle-url');

function updateLink(link) {
  var newLink = link.cloneNode();

  newLink.onload = function () {
    link.remove();
  };

  newLink.href = link.href.split('?')[0] + '?' + Date.now();
  link.parentNode.insertBefore(newLink, link.nextSibling);
}

var cssTimeout = null;

function reloadCSS() {
  if (cssTimeout) {
    return;
  }

  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');

    for (var i = 0; i < links.length; i++) {
      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {
        updateLink(links[i]);
      }
    }

    cssTimeout = null;
  }, 50);
}

module.exports = reloadCSS;
},{"./bundle-url":"../node_modules/parcel-bundler/src/builtins/bundle-url.js"}],"css/cookie-consent.css":[function(require,module,exports) {
var reloadCSS = require('_css_loader');

module.hot.dispose(reloadCSS);
module.hot.accept(reloadCSS);
},{"_css_loader":"../node_modules/parcel-bundler/src/builtins/css-loader.js"}],"fingerprint.js":[function(require,module,exports) {
var define;
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (a, c, b) {
  if (typeof module !== "undefined" && module.exports) {
    module.exports = b();
  } else {
    if (typeof define === "function" && define.amd) {
      define(b);
    } else {
      c[a] = b();
    }
  }
})("Fingerprint", this, function () {
  var a = function a(b) {
    var c, d;
    c = Array.prototype.forEach;
    d = Array.prototype.map;

    this.each = function (k, j, h) {
      if (k === null) {
        return;
      }

      if (c && k.forEach === c) {
        k.forEach(j, h);
      } else {
        if (k.length === +k.length) {
          for (var g = 0, e = k.length; g < e; g++) {
            if (j.call(h, k[g], g, k) === {}) {
              return;
            }
          }
        } else {
          for (var f in k) {
            if (k.hasOwnProperty(f)) {
              if (j.call(h, k[f], f, k) === {}) {
                return;
              }
            }
          }
        }
      }
    };

    this.map = function (h, g, f) {
      var e = [];

      if (h == null) {
        return e;
      }

      if (d && h.map === d) {
        return h.map(g, f);
      }

      this.each(h, function (k, i, j) {
        e[e.length] = g.call(f, k, i, j);
      });
      return e;
    };

    if (_typeof(b) == "object") {
      this.hasher = b.hasher;
      this.screen_resolution = b.screen_resolution;
      this.screen_orientation = b.screen_orientation;
      this.canvas = b.canvas;
      this.ie_activex = b.ie_activex;
    } else {
      if (typeof b == "function") {
        this.hasher = b;
      }
    }
  };

  a.prototype = {
    get: function get() {
      var c = [];
      c.push(navigator.userAgent);
      c.push(navigator.language);
      c.push(screen.colorDepth);

      if (this.screen_resolution) {
        var b = this.getScreenResolution();

        if (typeof b !== "undefined") {
          c.push(b.join("x"));
        }
      }

      c.push(new Date().getTimezoneOffset());
      c.push(this.hasSessionStorage());
      c.push(this.hasLocalStorage());
      c.push(this.hasIndexDb());

      if (document.body) {
        c.push(_typeof(document.body.addBehavior));
      } else {
        c.push(typeof undefined === "undefined" ? "undefined" : _typeof(undefined));
      }

      c.push(_typeof(window.openDatabase));
      c.push(navigator.cpuClass);
      c.push(navigator.platform);
      c.push(navigator.doNotTrack);
      c.push(this.getPluginsString());

      if (this.canvas && this.isCanvasSupported()) {
        c.push(this.getCanvasFingerprint());
      }

      if (this.hasher) {
        return this.hasher(c.join("###"), 31);
      } else {
        return this.murmurhash3_32_gc(c.join("###"), 31);
      }
    },
    murmurhash3_32_gc: function murmurhash3_32_gc(j, f) {
      var k, l, h, b, e, c, g, d;
      k = j.length & 3;
      l = j.length - k;
      h = f;
      e = 3432918353;
      c = 461845907;
      d = 0;

      while (d < l) {
        g = j.charCodeAt(d) & 255 | (j.charCodeAt(++d) & 255) << 8 | (j.charCodeAt(++d) & 255) << 16 | (j.charCodeAt(++d) & 255) << 24;
        ++d;
        g = (g & 65535) * e + (((g >>> 16) * e & 65535) << 16) & 4294967295;
        g = g << 15 | g >>> 17;
        g = (g & 65535) * c + (((g >>> 16) * c & 65535) << 16) & 4294967295;
        h ^= g;
        h = h << 13 | h >>> 19;
        b = (h & 65535) * 5 + (((h >>> 16) * 5 & 65535) << 16) & 4294967295;
        h = (b & 65535) + 27492 + (((b >>> 16) + 58964 & 65535) << 16);
      }

      g = 0;

      switch (k) {
        case 3:
          g ^= (j.charCodeAt(d + 2) & 255) << 16;

        case 2:
          g ^= (j.charCodeAt(d + 1) & 255) << 8;

        case 1:
          g ^= j.charCodeAt(d) & 255;
          g = (g & 65535) * e + (((g >>> 16) * e & 65535) << 16) & 4294967295;
          g = g << 15 | g >>> 17;
          g = (g & 65535) * c + (((g >>> 16) * c & 65535) << 16) & 4294967295;
          h ^= g;
      }

      h ^= j.length;
      h ^= h >>> 16;
      h = (h & 65535) * 2246822507 + (((h >>> 16) * 2246822507 & 65535) << 16) & 4294967295;
      h ^= h >>> 13;
      h = (h & 65535) * 3266489909 + (((h >>> 16) * 3266489909 & 65535) << 16) & 4294967295;
      h ^= h >>> 16;
      return h >>> 0;
    },
    hasLocalStorage: function hasLocalStorage() {
      try {
        return !!window.localStorage;
      } catch (b) {
        return true;
      }
    },
    hasSessionStorage: function hasSessionStorage() {
      try {
        return !!window.sessionStorage;
      } catch (b) {
        return true;
      }
    },
    hasIndexDb: function hasIndexDb() {
      try {
        return !!window.indexedDB;
      } catch (b) {
        return true;
      }
    },
    isCanvasSupported: function isCanvasSupported() {
      var b = document.createElement("canvas");
      return !!(b.getContext && b.getContext("2d"));
    },
    isIE: function isIE() {
      if (navigator.appName === "Microsoft Internet Explorer") {
        return true;
      } else {
        if (navigator.appName === "Netscape" && /Trident/.test(navigator.userAgent)) {
          return true;
        }
      }

      return false;
    },
    getPluginsString: function getPluginsString() {
      if (this.isIE() && this.ie_activex) {
        return this.getIEPluginsString();
      } else {
        return this.getRegularPluginsString();
      }
    },
    getRegularPluginsString: function getRegularPluginsString() {
      return this.map(navigator.plugins, function (c) {
        var b = this.map(c, function (d) {
          return [d.type, d.suffixes].join("~");
        }).join(",");
        return [c.name, c.description, b].join("::");
      }, this).join(";");
    },
    getIEPluginsString: function getIEPluginsString() {
      if (window.ActiveXObject) {
        var b = ["ShockwaveFlash.ShockwaveFlash", "AcroPDF.PDF", "PDF.PdfCtrl", "QuickTime.QuickTime", "rmocx.RealPlayer G2 Control", "rmocx.RealPlayer G2 Control.1", "RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)", "RealVideo.RealVideo(tm) ActiveX Control (32-bit)", "RealPlayer", "SWCtl.SWCtl", "WMPlayer.OCX", "AgControl.AgControl", "Skype.Detection"];
        return this.map(b, function (c) {
          try {
            new ActiveXObject(c);
            return c;
          } catch (d) {
            return null;
          }
        }).join(";");
      } else {
        return "";
      }
    },
    getScreenResolution: function getScreenResolution() {
      var b;

      if (this.screen_orientation) {
        b = screen.height > screen.width ? [screen.height, screen.width] : [screen.width, screen.height];
      } else {
        b = [screen.height, screen.width];
      }

      return b;
    },
    getCanvasFingerprint: function getCanvasFingerprint() {
      var d = document.createElement("canvas");
      var c = d.getContext("2d");
      var b = "http://valve.github.io";
      c.textBaseline = "top";
      c.font = "14px 'Arial'";
      c.textBaseline = "alphabetic";
      c.fillStyle = "#f60";
      c.fillRect(125, 1, 62, 20);
      c.fillStyle = "#069";
      c.fillText(b, 2, 15);
      c.fillStyle = "rgba(102, 204, 0, 0.7)";
      c.fillText(b, 4, 17);
      return d.toDataURL();
    }
  };
  return a;
});
},{}],"i18n.js":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function () {
  var e,
      t,
      n,
      r = function r(e, t) {
    return function () {
      return e.apply(t, arguments);
    };
  };

  e = function () {
    function e() {
      this.translate = r(this.translate, this);
      this.data = {
        values: {},
        contexts: []
      };
      this.globalContext = {};
    }

    e.prototype.translate = function (e, t, n, r, i) {
      var s, o, u, a;

      if (i == null) {
        i = this.globalContext;
      }

      u = function u(e) {
        var t;
        t = _typeof(e);
        return t === "function" || t === "object" && !!e;
      };

      if (u(t)) {
        s = null;
        a = null;
        o = t;
        i = n || this.globalContext;
      } else {
        if (typeof t === "number") {
          s = null;
          a = t;
          o = n;
          i = r || this.globalContext;
        } else {
          s = t;

          if (typeof n === "number") {
            a = n;
            o = r;
            i = i;
          } else {
            a = null;
            o = n;
            i = r || this.globalContext;
          }
        }
      }

      if (u(e)) {
        if (u(e["i18n"])) {
          e = e["i18n"];
        }

        return this.translateHash(e, i);
      } else {
        return this.translateText(e, a, o, i, s);
      }
    };

    e.prototype.add = function (e) {
      var t, n, r, i, s, o, u, a;

      if (e.values != null) {
        o = e.values;

        for (n in o) {
          r = o[n];
          this.data.values[n] = r;
        }
      }

      if (e.contexts != null) {
        u = e.contexts;
        a = [];

        for (i = 0, s = u.length; i < s; i++) {
          t = u[i];
          a.push(this.data.contexts.push(t));
        }

        return a;
      }
    };

    e.prototype.setContext = function (e, t) {
      return this.globalContext[e] = t;
    };

    e.prototype.clearContext = function (e) {
      return this.lobalContext[e] = null;
    };

    e.prototype.reset = function () {
      this.data = {
        values: {},
        contexts: []
      };
      return this.globalContext = {};
    };

    e.prototype.resetData = function () {
      return this.data = {
        values: {},
        contexts: []
      };
    };

    e.prototype.resetContext = function () {
      return this.globalContext = {};
    };

    e.prototype.translateHash = function (e, t) {
      var n, r;

      for (n in e) {
        r = e[n];

        if (typeof r === "string") {
          e[n] = this.translateText(r, null, null, t);
        }
      }

      return e;
    };

    e.prototype.translateText = function (e, t, n, r, i) {
      var s, o;

      if (r == null) {
        r = this.globalContext;
      }

      if (this.data == null) {
        return this.useOriginalText(i || e, t, n);
      }

      s = this.getContextData(this.data, r);

      if (s != null) {
        o = this.findTranslation(e, t, n, s.values, i);
      }

      if (o == null) {
        o = this.findTranslation(e, t, n, this.data.values, i);
      }

      if (o == null) {
        return this.useOriginalText(i || e, t, n);
      }

      return o;
    };

    e.prototype.findTranslation = function (e, t, n, r) {
      var i, s, o, u, a;
      o = r[e];

      if (o == null) {
        return null;
      }

      if (t == null) {
        if (typeof o === "string") {
          return this.applyFormatting(o, t, n);
        }
      } else {
        if (o instanceof Array || o.length) {
          for (u = 0, a = o.length; u < a; u++) {
            s = o[u];

            if ((t >= s[0] || s[0] === null) && (t <= s[1] || s[1] === null)) {
              i = this.applyFormatting(s[2].replace("-%n", String(-t)), t, n);
              return this.applyFormatting(i.replace("%n", String(t)), t, n);
            }
          }
        }
      }

      return null;
    };

    e.prototype.getContextData = function (e, t) {
      var n, r, i, s, o, u, a, f;

      if (e.contexts == null) {
        return null;
      }

      a = e.contexts;

      for (o = 0, u = a.length; o < u; o++) {
        n = a[o];
        r = true;
        f = n.matches;

        for (i in f) {
          s = f[i];
          r = r && s === t[i];
        }

        if (r) {
          return n;
        }
      }

      return null;
    };

    e.prototype.useOriginalText = function (e, t, n) {
      if (t == null) {
        return this.applyFormatting(e, t, n);
      }

      return this.applyFormatting(e.replace("%n", String(t)), t, n);
    };

    e.prototype.applyFormatting = function (e, t, n) {
      var r, i;

      for (r in n) {
        i = new RegExp("%{" + r + "}", "g");
        e = e.replace(i, n[r]);
      }

      return e;
    };

    return e;
  }();

  n = new e();
  t = n.translate;
  t.translator = n;

  t.create = function (n) {
    var r;
    r = new e();

    if (n != null) {
      r.add(n);
    }

    r.translate.create = t.create;
    return r.translate;
  };

  (typeof module !== "undefined" && module !== null ? module.exports = t : void 0) || (this.i18n = t);
}).call(this);
},{}],"lang/sv.json":[function(require,module,exports) {
module.exports = {
  "values": {
    "necessary": "Nödvändiga cookies för webbsidans funktion (i linje med GDPR)",
    "other": "Cookies för att mäta besök, anpassa innehåll och annonser",
    "ccTitle": "Vår webbplats använder cookies",
    "ccText": "Vi använder cookies för att förbättra din upplevelse, analysera trafik och anpassa marknadsföring. Godkänn våra cookies eller finjustera under Inställningar.",
    "ccSettingsLabel": "Inställningar",
    "ccAcceptCookies": "Acceptera cookies",
    "ccAcceptCookieSettings": "Spara inställningar",
    "ccReadMoreLabel": "Läs mer om cookies",
    "ccReadMoreURL": "om-cookies"
  }
};
},{}],"lang/en.json":[function(require,module,exports) {
module.exports = {
  "values": {
    "necessary": "Cookies necessary for the website to function properly in line with GDPR",
    "other": "Cookies for tracking visits, personalizing content and adverts",
    "ccTitle": "This web site uses cookies",
    "ccText": "We use cookies in order to enrich and personalize your experience, understand traffic and target ads. You can approve the default cookies, or fine tune them under Settings.",
    "ccSettingsLabel": "Settings",
    "ccAcceptCookies": "Accept cookies",
    "ccAcceptCookieSettings": "Save settings",
    "ccReadMoreLabel": "Read more about cookies",
    "ccReadMoreURL": "about-cookies"
  }
};
},{}],"../node_modules/yett/dist/yett.min.js":[function(require,module,exports) {
var define;
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).yett={})}(this,function(t){"use strict";function o(e,t){return e&&(!t||t!==s)&&(!a.blacklist||a.blacklist.some(function(t){return t.test(e)}))&&(!a.whitelist||a.whitelist.every(function(t){return!t.test(e)}))}function l(t){var e=t.getAttribute("src");return a.blacklist&&a.blacklist.every(function(t){return!t.test(e)})||a.whitelist&&a.whitelist.some(function(t){return t.test(e)})}var s="javascript/blocked",a={blacklist:window.YETT_BLACKLIST,whitelist:window.YETT_WHITELIST},u={blacklisted:[]},p=new MutationObserver(function(t){for(var e=0;e<t.length;e++)for(var i=t[e].addedNodes,n=function(t){var n=i[t];if(1===n.nodeType&&"SCRIPT"===n.tagName){var e=n.src,r=n.type;if(o(e,r)){u.blacklisted.push(n.cloneNode()),n.type=s;n.addEventListener("beforescriptexecute",function t(e){n.getAttribute("type")===s&&e.preventDefault(),n.removeEventListener("beforescriptexecute",t)}),n.parentElement&&n.parentElement.removeChild(n)}}},r=0;r<i.length;r++)n(r)});p.observe(document.documentElement,{childList:!0,subtree:!0});var c=document.createElement;function f(t){return function(t){if(Array.isArray(t)){for(var e=0,n=new Array(t.length);e<t.length;e++)n[e]=t[e];return n}}(t)||function(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}document.createElement=function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];if("script"!==e[0].toLowerCase())return c.bind(document).apply(void 0,e);var r=c.bind(document).apply(void 0,e),i=r.setAttribute.bind(r);try{Object.defineProperties(r,{src:{get:function(){return r.getAttribute("src")},set:function(t){return o(t,r.type)&&i("type",s),i("src",t),!0}},type:{set:function(t){var e=o(r.src,r.type)?s:t;return i("type",e),!0}}}),r.setAttribute=function(t,e){"type"===t||"src"===t?r[t]=e:HTMLScriptElement.prototype.setAttribute.call(r,t,e)}}catch(t){console.warn("Yett: unable to prevent script execution for script src ",r.src,".\n",'A likely cause would be because you are using a third-party browser extension that monkey patches the "document.createElement" function.')}return r};var d=new RegExp("[|\\{}()[\\]^$+*?.]","g");t.unblock=function(){for(var t=arguments.length,n=new Array(t),e=0;e<t;e++)n[e]=arguments[e];n.length<1?(a.blacklist=[],a.whitelist=[]):(a.blacklist&&(a.blacklist=a.blacklist.filter(function(e){return n.every(function(t){return"string"==typeof t?!e.test(t):t instanceof RegExp?e.toString()!==t.toString():void 0})})),a.whitelist&&(a.whitelist=[].concat(f(a.whitelist),f(n.map(function(e){if("string"==typeof e){var n=".*"+e.replace(d,"\\$&")+".*";if(a.whitelist.every(function(t){return t.toString()!==n.toString()}))return new RegExp(n)}else if(e instanceof RegExp&&a.whitelist.every(function(t){return t.toString()!==e.toString()}))return e;return null}).filter(Boolean)))));for(var r=document.querySelectorAll('script[type="'.concat(s,'"]')),i=0;i<r.length;i++){var o=r[i];l(o)&&(o.type="application/javascript",u.blacklisted.push(o),o.parentElement.removeChild(o))}var c=0;f(u.blacklisted).forEach(function(t,e){if(l(t)){var n=document.createElement("script");n.setAttribute("src",t.src),n.setAttribute("type","application/javascript"),document.head.appendChild(n),u.blacklisted.splice(e-c,1),c++}}),a.blacklist&&a.blacklist.length<1&&p.disconnect()},Object.defineProperty(t,"__esModule",{value:!0})});


},{}],"cookie-consent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sv = _interopRequireDefault(require("./lang/sv.json"));

var _en = _interopRequireDefault(require("./lang/en.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var whitelist;
var categories;
var current_language;
var base_path;
var strings = {
  sv: _sv.default,
  en: _en.default
};
var yett;

function initiate() {
  window.YETT_WHITELIST = whitelist;
  yett = require("yett");
  categories = [{
    key: "necessary",
    mutable: false,
    default: "on"
  }, {
    key: "other",
    mutable: true,
    default: "off"
  }];
  document.addEventListener("DOMContentLoaded", function () {
    setup();
  });
} // has user accepted all cookies? (rather, more than necessary)


function _acceptedAll() {
  return localStorage.getItem("category") == "all";
}

function _isset() {
  return localStorage.getItem("category") != null;
} // setup component and draw it to screen


function setup() {
  var translation_file = base_path + "lang/" + current_language + ".json";
  var data = strings[current_language];
  i18n.translator.add(data);
  var el = document.createElement("div");
  el.setAttribute("id", "cookieconsent");
  el.innerHTML = "\n\t\t\t\t<div\n\t\t\t\t\trole=\"dialog\"\n\t\t\t\t\taria-live=\"polite\"\n\t\t\t\t\taria-labelledby=\"ccTitle\"\n\t\t\t\t\taria-describedby=\"ccDesc\"\n\t\t\t\t\tclass=\"cc cc--bl cc--bs\"\n\t\t\t\t>\n\t\t\t\t\t<div role=\"document\" tabindex=\"0\">\n\t\t\t\t\t\t<h2 id=\"ccTitle\">".concat(i18n("ccTitle"), "</h2>\n\t\t\t\t\t\t<p id=\"ccDesc\">").concat(i18n("ccText"), " <a href='").concat(i18n("ccReadMoreURL"), "' class='cc__more'>").concat(i18n("ccReadMoreLabel"), "</a></p>\n\t\t\t\t\t\t<div class=\"cc__settingsWrapper\">\n\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\tclass=\"cc__settingsButton\"\n\t\t\t\t\t\t\t\tid=\"cc__settingsButton\"\n\t\t\t\t\t\t\t\taria-expanded=\"false\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<svg \n\t\t\t\t\t\t\t\t\tclass=\"cc__icon-open\"\n\t\t\t\t\t\t\t\t\taria-hidden=\"true\"\n\t\t\t\t\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\" \n\t\t\t\t\t\t\t\t\twidth=\"24\" \n\t\t\t\t\t\t\t\t\theight=\"24\" \n\t\t\t\t\t\t\t\t\tviewBox=\"0 0 24 24\" \n\t\t\t\t\t\t\t\t\tfill=\"none\" \n\t\t\t\t\t\t\t\t\tstroke=\"currentColor\" \n\t\t\t\t\t\t\t\t\tstroke-width=\"2\" \n\t\t\t\t\t\t\t\t\tstroke-linecap=\"round\" \n\t\t\t\t\t\t\t\t\tstroke-linejoin=\"round\" \n\t\t\t\t\t\t\t\t\tclass=\"feather feather-plus-circle\">\n\t\t\t\t\t\t\t\t\t\t<circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\n\t\t\t\t\t\t\t\t\t\t<line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"16\"></line>\n\t\t\t\t\t\t\t\t\t\t<line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>\n\t\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t\t\t<svg\n\t\t\t\t\t\t\t\t\thidden\n\t\t\t\t\t\t\t\t\tclass=\"cc__icon-close\"\n\t\t\t\t\t\t\t\t\taria-hidden=\"true\"\n\t\t\t\t\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\" \n\t\t\t\t\t\t\t\t\twidth=\"24\" \n\t\t\t\t\t\t\t\t\theight=\"24\" \n\t\t\t\t\t\t\t\t\tviewBox=\"0 0 24 24\" \n\t\t\t\t\t\t\t\t\tfill=\"none\" \n\t\t\t\t\t\t\t\t\tstroke=\"currentColor\" \n\t\t\t\t\t\t\t\t\tstroke-width=\"2\" \n\t\t\t\t\t\t\t\t\tstroke-linecap=\"round\" \n\t\t\t\t\t\t\t\t\tstroke-linejoin=\"round\" \n\t\t\t\t\t\t\t\t\tclass=\"feather feather-minus-circle\">\n\t\t\t\t\t\t\t\t\t\t<circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\n\t\t\t\t\t\t\t\t\t\t<line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>\n\t\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t\t\t").concat(i18n("ccSettingsLabel"), "\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t<div id=\"cc__settings\">\n\t\t\t\t\t\t\t\t").concat(categories.map(function (category) {
    return "\n\t\t\t\t\t\t\t\t\t<label class=\"cc__checkbox-label ".concat(category.mutable ? "" : "cc__checkbox-label--disabled", "\">\n\t\t\t\t\t\t\t\t\t\t<input type=\"checkbox\" value=\"").concat(category.key, "\" autocomplete=\"off\"\n\t\t\t\t\t\t\t\t\t\t\t\t").concat(category.default === "on" ? "checked" : "", "\n\t\t\t\t\t\t\t\t\t\t\t\t").concat(!category.mutable ? "disabled" : "", "\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t<span class=\"cc__checkbox-checkmark\"></span>\n\t\t\t\t\t\t\t\t\t\t").concat(i18n(category.key), "\n\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t");
  }).join(""), "\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<button class=\"cc__acceptButton\" id=\"cc__acceptButton\">\n\t\t\t\t\t\t\t<svg\n\t\t\t\t\t\t\t\taria-hidden=\"true\"\n\t\t\t\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\t\t\t\tfill=\"none\"\n\t\t\t\t\t\t\t\tstroke=\"currentColor\"\n\t\t\t\t\t\t\t\tstroke-linecap=\"round\"\n\t\t\t\t\t\t\t\tstroke-linejoin=\"round\"\n\t\t\t\t\t\t\t\tstroke-width=\"4\"\n\t\t\t\t\t\t\t\tclass=\"feather feather-check\"\n\t\t\t\t\t\t\t\tviewBox=\"0 0 24 24\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<defs />\n\t\t\t\t\t\t\t\t<path d=\"M20 6L9 17l-5-5\" />\n\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t\t<span>").concat(i18n("ccAcceptCookies"), "</span>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t");
  document.body.appendChild(el); // if all categories has been accepted, unblock yett

  if (_acceptedAll()) {
    yett.unblock();
  } // if category has been set,
  // dont do anything, just hide.


  if (_isset()) {
    el.classList.add("cc--hidden"); // return false;
  }

  var ccActive = false; // Show/hide settings panel

  var ccAccept = document.querySelector("#cc__acceptButton");
  var ccAcceptSpan = ccAccept.querySelector("span");
  var ccSettingsWrapper = document.querySelector(".cc__settingsWrapper");
  var ccSettingsButton = document.querySelector("#cc__settingsButton");
  var ccOpenIcon = document.querySelector(".cc__icon-open");
  var ccCloseIcon = document.querySelector(".cc__icon-close");
  var ccSettingsAlt = document.querySelector("#cc__settings");
  ccSettingsButton.addEventListener("click", function () {
    if (ccSettingsAlt.classList.contains("cc-active")) {
      this.setAttribute("aria-expanded", "false");
      ccSettingsAlt.classList.remove("cc-active");
      ccSettingsWrapper.classList.remove("cc__settingsWrapper--active");
      ccAcceptSpan.innerHTML = i18n("ccAcceptCookies");
      ccOpenIcon.removeAttribute("hidden");
      ccCloseIcon.setAttribute("hidden", "hidden");
    } else {
      ccSettingsAlt.classList.add("cc-active");
      ccSettingsWrapper.classList.add("cc__settingsWrapper--active");
      this.setAttribute("aria-expanded", "true");
      ccAcceptSpan.innerHTML = i18n("ccAcceptCookieSettings");
      ccOpenIcon.setAttribute("hidden", "hidden");
      ccCloseIcon.removeAttribute("hidden");
    }

    ccActive = true;
  }); // Accept cookies

  ccAccept.addEventListener("click", function (e) {
    var category = "necessary";
    var cbs = document.querySelectorAll("#cc__settings input");

    for (var i = 0; i < cbs.length; i++) {
      //TODO: handle multiple categories
      //alpha version explanation:
      //in this version we either accept cookies or not
      //if other isnt checked, only the whitelist gets loaded
      //so we need only act on this
      //in future versions this will not do
      //we will have to rework this into something
      //a weeeee bit more versatile :-P
      if (cbs[i].value == "other" && cbs[i].checked || !ccActive) {
        yett.unblock();
        category = "all";
      }
    }

    localStorage.setItem("category", category);
    el.classList.add("cc--hidden");
    e.preventDefault();
  });
  el.addEventListener("click", function (e) {
    var target = e.target || e.currentTarget;

    if (parentHasClassName(target, "cc__settingsWrapper") !== true) {
      if (ccSettingsAlt.classList.contains("cc-active")) {
        ccSettingsButton.click();
      }
    }
  });
}

function fetchJSONFile(path, callback) {
  var httpRequest = new XMLHttpRequest();

  httpRequest.onreadystatechange = function () {
    if (httpRequest.readyState === 4) {
      if (httpRequest.status === 200) {
        var data = JSON.parse(httpRequest.responseText);
        if (callback) callback(data);
      }
    }
  };

  httpRequest.open("GET", path);
  httpRequest.send();
}

function parentHasClassName(element, classname) {
  return element && (element.classList && element.classList.contains(classname) || element.parentNode && parentHasClassName(element.parentNode, classname));
}

var _default = {
  // public init function, call this with below parameters
  init: function init(params) {
    current_language = params.current_language;
    whitelist = params.whitelist;
    categories = params.categories;
    base_path = params.base_path;
    initiate();
  },
  // clears all settings and pops up the cookie selector
  clearSettings: function clearSettings() {
    localStorage.removeItem("category");
    localStorage.removeItem("fingerprinted");
    var cc = document.querySelector("#cookieconsent");

    if (cc != null) {
      cc.classList.remove("cc--hidden");
    } else {
      initiate();
    }
  },
  acceptedAll: function acceptedAll() {
    return _acceptedAll();
  },
  isset: function isset() {
    return _isset();
  }
};
exports.default = _default;
},{"./lang/sv.json":"lang/sv.json","./lang/en.json":"lang/en.json","yett":"../node_modules/yett/dist/yett.min.js"}],"index.js":[function(require,module,exports) {
"use strict";

require("./css/cookie-consent.css");

var _fingerprint = _interopRequireDefault(require("./fingerprint"));

var _i18n = _interopRequireDefault(require("./i18n"));

var _cookieConsent2 = _interopRequireDefault(require("./cookie-consent"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.i18n = _i18n.default;
window.Fingerprint = _fingerprint.default;
module.exports = _cookieConsent2.default;
},{"./css/cookie-consent.css":"css/cookie-consent.css","./fingerprint":"fingerprint.js","./i18n":"i18n.js","./cookie-consent":"cookie-consent.js"}],"../node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "60171" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.js"], "CookieConsent")
//# sourceMappingURL=/cookie-consent.min.js.map